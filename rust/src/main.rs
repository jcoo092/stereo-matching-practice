// This is a special-purpose branch of the program which will never be merged into master
// It is specifically made to help me with writing examples of the process elsewhere
// by writing out the complete text version of what I'm doing

use std::io::BufRead;
use std::io::Read;
use std::io::Write;
use std::path::PathBuf;
use structopt::StructOpt;

mod beliefpropagation;
mod common;
mod data;
mod smoothness;

#[derive(Debug)]
enum Algorithms {
    SAD,
    SSD,
    DynamicProgramming,
    BeliefPropagation,
}

impl std::str::FromStr for Algorithms {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "sad" => Ok(Algorithms::SAD),
            "ssd" => Ok(Algorithms::SSD),
            "dynamicprogramming" | "dynamic_programming" | "dynamic-programming" | "dp" => {
                Ok(Algorithms::DynamicProgramming)
            }
            "beliefpropagation" | "belief_propagation" | "belief-propagation" | "bp" => {
                Ok(Algorithms::BeliefPropagation)
            }
            _ => Err(
                "Parsing of the algorithm failed.  Please specify one of the possible options."
                    .to_string(),
            ),
        }
    }
}

impl std::fmt::Display for Algorithms {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let algo_string = match self {
            Algorithms::SAD => "sad",
            Algorithms::SSD => "ssd",
            Algorithms::DynamicProgramming => "dynamic-programming",
            Algorithms::BeliefPropagation => "belief-propagation",
        };
        write!(f, "{}", algo_string)
    }
}

#[derive(Debug, StructOpt)]
#[structopt(
    name = "Practice stereo matcher",
    about = "A command-line program to execute various stereo matching algorithms on stereo pairs of images."
)]
struct CLIParameters {
    #[structopt(
        short = "l",
        parse(from_os_str),
        help = "Path to the left image to be matched on."
    )]
    left_image_path: PathBuf,
    #[structopt(
        short = "r",
        parse(from_os_str),
        help = "Path to the right image to be matched on."
    )]
    right_image_path: PathBuf,
    #[structopt(
        short = "o",
        parse(from_os_str),
        help = "Path to the output directory for the disparity map to be output to.\nNote that you DO NOT provide a filename, just the directory.  The filename is generated by the program itself."
    )]
    output_directory: PathBuf,
    #[structopt(
        short = "w",
        help = "The size of a side of the square window you would like to use for the matching.  Currently only relevant to SAD and SSD."
    )]
    window_size: Option<usize>,
    #[structopt(
        short = "d",
        help = "The maximum disparity size that the program will search out to (defaults to 32)."
    )]
    maximum_disparity: Option<usize>,
    #[structopt(
        short = "a",
        help = "The algorithm you would like to use for the stereo matching."
    )]
    algorithm: Algorithms,
    #[structopt(
        short = "n",
        help = "The number of iterations of the algorithm to carry out.  Currently only relevant to belief propagation."
    )]
    number_of_iterations: Option<usize>,
    #[structopt(
        short = "z",
        help = "Set this flag if you would like the program to use the zero-mean version of the unary cost function.  (Currently does nothing)"
    )]
    use_zero_mean: bool,
    #[structopt(
        short = "png",
        help = "Set this flag if you would like the program to save the output image as a png.  Otherwise, it defaults to using the same file extension as on the left input image.  (Currently does nothing)"
    )]
    save_as_png: bool,
}

fn determine_output_file_path(params: &CLIParameters) -> PathBuf {
    let algorithm_string = format!("{}", params.algorithm);
    let left_image_name_without_extension = params
        .left_image_path
        .file_stem()
        .expect("Left image name apparently has no file name (???)")
        .to_str()
        .unwrap();

    let left_image_extension = {
        if params.save_as_png {
            ".png"
        } else {
            params
                .left_image_path
                .extension()
                .expect("Left image name apparently has no extension (???)")
                .to_str()
                .unwrap()
        }
    };

    let window_size = if params.window_size.is_some() {
        format!("{}", params.window_size.unwrap())
    } else {
        String::new()
    };

    let number_of_iterations = if params.number_of_iterations.is_some() {
        format!("{}", params.number_of_iterations.unwrap())
    } else {
        String::new()
    };

    let mut filename = params.output_directory.to_owned();

    filename.push(
        &[
            "rust",
            left_image_name_without_extension,
            &algorithm_string,
            &window_size,
            &number_of_iterations,
        ]
        .join("_"),
    );

    filename.set_extension(left_image_extension);
    filename
}

fn main() {
    let cli_parameters = CLIParameters::from_args();
    assert!(cli_parameters.output_directory.is_dir());
    let output_filename = determine_output_file_path(&cli_parameters);

    let start_time = std::time::Instant::now();

    // let left_image = image::open(cli_parameters.left_image_path).expect("Couldn't open left image");

    // let (image_width, image_height) = left_image.dimensions();

    // let left_image_buffer = left_image.grayscale().raw_pixels();
    // let right_image_buffer = image::open(cli_parameters.right_image_path)
    //     .expect("Couldn't open right image")
    //     .grayscale()
    //     .raw_pixels();

    let left_image_buffer = parse_file_to_numbers_array(&cli_parameters.left_image_path);
    let right_image_buffer = parse_file_to_numbers_array(&cli_parameters.right_image_path);

    let (image_width, image_height) =
        determine_image_width_and_height_from_file(&cli_parameters.left_image_path);

    let parameters = common::Parameters {
        left_image: &left_image_buffer,
        right_image: &right_image_buffer,
        width: image_width as usize,
        height: image_height as usize,
        total_pixels: (image_width as usize) * (image_height as usize),
        window_edge_size: cli_parameters.window_size.unwrap_or(3),
        maximum_disparity: cli_parameters.maximum_disparity.unwrap_or(32),
        use_zero_mean: cli_parameters.use_zero_mean,
    };

    let algo_start_time = std::time::Instant::now();

    let output_vec = {
        match cli_parameters.algorithm {
            Algorithms::SAD => unimplemented!(),
            Algorithms::SSD => unimplemented!(),
            Algorithms::DynamicProgramming => unimplemented!(),
            Algorithms::BeliefPropagation => {
                let bpparameters = beliefpropagation::BPParameters {
                    number_of_iterations: cli_parameters.number_of_iterations.unwrap_or(10),
                    data_cost_function: |a, b| {
                        data::truncated_linear_f32_fh(common::LAMBDA_FH, common::TAU_FH, a, b)
                    },
                    smoothness_cost_function: |a, b| {
                        smoothness::truncated_linear_f32_fh(common::D_FH, a, b)
                    },
                };
                beliefpropagation::belief_propagation(&parameters, &bpparameters)
            }
        }
    };

    let algo_end_time = std::time::Instant::now();

    // let mut output_image = image::ImageBuffer::<image::Luma<u8>, Vec<u8>>::from_raw(
    //     image_width,
    //     image_height,
    //     output_vec,
    // )
    // .expect("Error creating the output image!");
    // imageproc::contrast::equalize_histogram_mut(&mut output_image);

    // assert!(output_image.save(output_filename).is_ok());

    let mut output_file = std::io::LineWriter::new(std::fs::File::create(output_filename).unwrap());
    // output_file.write_all(b"Left Image:\n").unwrap();
    // // output_file.write(&left_image_buffer);
    // left_image_buffer
    //     .chunks(image_width)
    //     .map(|chunk| output_file.write(chunk))
    //     .all(|r| r.is_ok());
    write_image_to_file(&mut output_file, &left_image_buffer, image_width, "Left");

    // output_file.write_all(b"\n\nRight Image:\n").unwrap();
    // right_image_buffer
    //     .chunks(image_width)
    //     .map(|chunk| output_file.write(chunk))
    //     .all(|r| r.is_ok());
    write_image_to_file(&mut output_file, &right_image_buffer, image_width, "Right");

    // output_file.write_all(b"\n\nOuput Image:\n").unwrap();
    // output_vec
    //     .chunks(image_width)
    //     .map(|chunk| output_file.write(chunk))
    //     .all(|r| r.is_ok());
    write_image_to_file(&mut output_file, &output_vec, image_width, "Output");

    let end_time = std::time::Instant::now();

    println!(
        "Algorithm running time was {:?}.",
        algo_end_time.duration_since(algo_start_time)
    );
    println!(
        "Full running time was {:?}.",
        end_time.duration_since(start_time)
    );
}

fn parse_file_to_numbers_array(filename: &PathBuf) -> Vec<u8> {
    let buffered = std::io::BufReader::new(std::fs::File::open(filename).unwrap());
    parse_buffer_to_numbers_array(buffered)
}

fn parse_buffer_to_numbers_array<U: BufRead>(buf: U) -> Vec<u8> {
    buf.lines()
        .flat_map(|line| {
            line.unwrap()
                .split(',')
                .map(|n| n.parse::<u8>().unwrap())
                .collect::<Vec<_>>()
        })
        .collect::<Vec<_>>()
}

fn determine_image_width_and_height_from_file(filename: &PathBuf) -> (usize, usize) {
    let mut buffered = std::io::BufReader::new(std::fs::File::open(filename).unwrap());
    let width = buffered
        .by_ref()
        .lines()
        .peekable()
        .peek()
        .unwrap()
        .as_ref()
        .unwrap()
        .split(',')
        .count();

    let height = buffered.lines().count();

    (width, height + 1)
}

fn write_image_to_file(
    writer: &mut std::io::LineWriter<std::fs::File>,
    vec_to_write: &[u8],
    image_width: usize,
    image_name: &str,
) {
    writer
        .write_fmt(format_args!("\n\n{} Image:\n", image_name))
        .unwrap();
    vec_to_write
        .chunks(image_width)
        .for_each(|chunk| writer.write_fmt(format_args!("{:?}\n", chunk)).unwrap());
    writer
        .flush()
        .expect("Failed on flushing the write to the image");
}

#[cfg(test)]
mod tests {
    use super::determine_image_width_and_height_from_file;
    use super::parse_buffer_to_numbers_array;
    use super::parse_file_to_numbers_array;
    use super::write_image_to_file;

    #[test]
    fn test_parse_file_to_numbers_array() {
        let expected: Vec<u8> = vec![
            19, 20, 34, 159, 167, 20, 21, 103, 191, 173, 18, 60, 189, 191, 199, 53, 185, 197, 201,
            198, 175, 205, 195, 198, 203,
        ];
        assert_eq!(
            expected,
            parse_file_to_numbers_array(&std::path::PathBuf::from("leftimage.txt"))
        );
    }

    #[test]
    fn test_parse_buffer_to_numbers_array() {
        let actual_cursor = std::io::Cursor::new("19,20,34,159,167\n20,21,103,191,173\n18,60,189,191,199\n53,185,197,201,198\n175,205,195,198,203");

        let expected: Vec<u8> = vec![
            19, 20, 34, 159, 167, 20, 21, 103, 191, 173, 18, 60, 189, 191, 199, 53, 185, 197, 201,
            198, 175, 205, 195, 198, 203,
        ];

        assert_eq!(expected, parse_buffer_to_numbers_array(actual_cursor));
    }

    #[test]
    fn test_determine_image_width_and_height_from_file() {
        let (expected_width, expected_height) = (5, 5);
        let file = std::path::PathBuf::from("leftimage.txt");
        let (actual_width, actual_height) = determine_image_width_and_height_from_file(&file);
        assert!(expected_width == actual_width && expected_height == actual_height);
    }

    // Currently this one doesn't actually include an assertion - you have to eyeball the file manually
    #[test]
    fn test_write_image_to_file() {
        let vec_to_write: Vec<u8> = vec![
            19, 20, 34, 159, 167, 20, 21, 103, 191, 173, 18, 60, 189, 191, 199, 53, 185, 197, 201,
            198, 175, 205, 195, 198, 203,
        ];

        let image_width = 5;
        let image_name = "Test";
        let mut test_output_writer = std::io::LineWriter::new(
            std::fs::File::create("test_write_image_to_file.txt").unwrap(),
        );
        write_image_to_file(
            &mut test_output_writer,
            &vec_to_write,
            image_width,
            image_name,
        );
    }
}
